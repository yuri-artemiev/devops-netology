# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

- Найдём идентификатор операций, которые выполняются дольше 3 минут  
    ```
    db.currentOp({ "active" : true, "secs_running" : { "$gt" : 180 }})
    ```
- Завершим операцию по opid  
    ```
    db.killOp(<opid>)
    ```
- Дла решения проблем с зависающими запросам можно использовать анализ палана выполнения долгого запроса - команда `explain`. После чего можно использовать индексы или оптимизировать запрос. Также можно рассмотреть возможность увеличения ресурсов сервера.  



## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:  
- сначала рост отношения записанных значений к истекшим  
- Redis блокирует операции записи  

Как вы думаете, в чем может быть проблема?  

- Возможно проблема в том, что множество ключей истекает в одно и то же время. Если в базе данных есть много ключей, истекающих в ту же секунду, и они составляют не менее 25% ключей с истёкшим сроком действия, Redis может заблокировать их, чтобы снизить процент уже истекших ключей ниже 25%.





 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
Как вы думаете, почему это начало происходить и как локализовать проблему?  
Какие пути решения данной проблемы вы можете предложить?  

- Возможные причины: 
    - Запрос может долго выполняться на сервере  
    - Запрос может долго пересылаться  
    - Запрос может быть большим по размеру  
- Возможноые пути решения:  
    - Увеличить таймауты:  
        - `net_read_timeout`  
        - `connect_timeout`  
    - Увеличить максимальный размер передаваемого пакета:  
        - `max_allowed_packet`  





## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?  
Как бы вы решили данную проблему?  

- OOM Killer - процесс, который завершает приложение при нехватки памяти. Возможно ошибка говорит о том, что доступная память на сервере закончилась и oom-killer завершил процесс PostgreSQL. Это необходимо, чтобы не обрушилась вся система.

Варианты решения:
- Ограничить потребление память PostgreSQL. Например, добавиви в файл конфигурации `postgresql.conf` параметры `shared_buffers`, `work_mem`  
- Изменить приоритет PostgreSQL процесса (oom_score_adj). Например, добавив в unit файл сервиса параметр `OOMScoreAdjust=-1000`  
- Увеличить вероятность записи памяти на диск (swap). Например, добавив в файл кофигурации `/etc/sysctl.d/99-swappiness.conf` параметр `vm.swappiness = 100`  
- Увеличить ресурсы добавив оперативной памяти на сервер  

